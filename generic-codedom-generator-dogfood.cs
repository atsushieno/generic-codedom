//
// Code generator for Mono.CodeDom.Generic types.
//
// This tool automatically generates Mono.CodeDom.Generic types from
// System.CodeDom types in System.dll.
//

using System;
#if USE_OLD
using System.CodeDom;
#else
using Mono.CodeDom.Generic;
#endif
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Xml;
using Microsoft.CSharp;

using MemberAttributes = System.CodeDom.MemberAttributes;
using OldCodeCompileUnit = System.CodeDom.CodeCompileUnit;
using OldCodeNamespaceImportCollection = System.CodeDom.CodeNamespaceImportCollection;

namespace Mono.CodeDom.Generic
{
	public class Driver
	{
		public static void Main ()
		{
			new Driver ().Run ();
		}

		Assembly ass;
		CodeCompileUnit ccu;
		CodeNamespace cns;
		TextWriter output = new StringWriter ();

		public void Run ()
		{
			ass = typeof (OldCodeCompileUnit).Assembly;
			GenerateCode ();
		}
		
		void GenerateCode ()
		{
			ccu = new CodeCompileUnit ();
			cns = new CodeNamespace ("Mono.CodeDom.Generic");
			ccu.Namespaces.Add (cns);
			cns.Comments.Add (new CodeCommentStatement ("This file is generated by codedom-generic skeleton generator."));
			cns.Imports.Add (new CodeNamespaceImport ("System"));
			cns.Imports.Add (new CodeNamespaceImport ("System.CodeDom"));
			cns.Imports.Add (new CodeNamespaceImport ("System.Collections"));
			cns.Imports.Add (new CodeNamespaceImport ("System.Collections.Generic"));
			cns.Imports.Add (new CodeNamespaceImport ("System.Collections.Specialized"));
			cns.Imports.Add (new CodeNamespaceImport ("System.Linq"));
			cns.Imports.Add (new CodeNamespaceImport ("System.Reflection"));

			// type name aliases are removed in this CodeDom-based generator.

			var types = from tt in ass.GetTypes () where tt.IsPublic && tt.Namespace == "System.CodeDom" select tt;
			foreach (var t in types) {
				if (t == typeof (OldCodeNamespaceImportCollection))
					continue; // special: this cannot be automatically imported.
				if (t.BaseType == typeof (CollectionBase))
					GenerateCollectionTypeCode (t);
//				else if (!t.IsEnum)
//					GenerateOrdinalTypeCode (t);
			}

			var sw = new StringWriter ();
			try {
				new CSharpCodeProvider ().GenerateCodeFromCompileUnit ((OldCodeCompileUnit) ccu, sw, null);
			} catch (Exception) {
				Console.Error.WriteLine (sw);
				throw;
			}
			using (var fs = File.CreateText ("generic-codedom.generated.dogfood.cs"))
				fs.Write (sw);
		}
		
		void GenerateCollectionTypeCode (Type type)
		{
			string itemName = type.Name.Substring (0, type.Name.LastIndexOf ("Collection"));
			string collName = type.Name;
			string oldItemName = "System.CodeDom." + itemName;
			string oldCollName = "System.CodeDom." + itemName + "Collection";

			var ctd = new CodeTypeDeclaration (collName);
			cns.Types.Add (ctd);
			ctd.BaseTypes.Add (new CodeTypeReference ("Mono.CodeDom.Generic.CodeDomCollection", new CodeTypeReference (itemName), new CodeTypeReference (oldItemName), new CodeTypeReference (oldCollName)));
			var ctor1 = new CodeConstructor ();
			ctd.Members.Add (ctor1);
			ctor1.Attributes |= MemberAttributes.Assembly;
			ctor1.Parameters.Add (new CodeParameterDeclarationExpression (oldCollName, "c"));
			ctor1.BaseConstructorArgs.Add (new CodeArgumentReferenceExpression ("c"));
			var ctor2 = new CodeConstructor ();
			ctd.Members.Add (ctor2);
			ctor2.Attributes |= MemberAttributes.Public;

			var ctor3 = new CodeConstructor ();
			ctd.Members.Add (ctor3);
			ctor3.Attributes |= MemberAttributes.Public;
			ctor3.Parameters.Add (new CodeParameterDeclarationExpression (collName, "source"));
			ctor3.BaseConstructorArgs.Add (new CodeArgumentReferenceExpression ("source"));

			var ctor4 = new CodeConstructor ();
			ctd.Members.Add (ctor4);
			ctor4.Attributes |= MemberAttributes.Public;
			var vararg = new CodeParameterDeclarationExpression (new CodeTypeReference (itemName, 1), "value");
			vararg.CustomAttributes.Add (new CodeAttributeDeclaration (new CodeTypeReference (typeof (ParamArrayAttribute))));
			ctor4.Parameters.Add (vararg);
			ctor4.BaseConstructorArgs.Add (new CodeArgumentReferenceExpression ("value"));

			var toOld = new CodeMemberMethod () { Name = "ToOld", ReturnType = new CodeTypeReference (oldItemName) };
			ctd.Members.Add (toOld);
			toOld.Attributes = MemberAttributes.Assembly;
			toOld.Parameters.Add (new CodeParameterDeclarationExpression (new CodeTypeReference (itemName), "item"));
			toOld.Statements.Add (new CodeMethodReturnStatement (new CodeCastExpression (new CodeTypeReference (oldItemName), new CodeArgumentReferenceExpression ("item"))));
		}

/*
		void GenerateOrdinalTypeCode (Type type)
		{
			var ctd = new CodeTypeDeclaration (type.Name);
			ctd.BaseTypes.Add (new CodeTypeReference ((type.BaseType.Namespace == "System.CodeDom" ? "Mono.CodeDom.Generic." : null) + type.BaseType.Name);
			var oldType = new CodeTypeReference (type);
			var old = new CodeMemberField (oldType, "old");
			ctd.Members.Add (old);
			
			var domprops = new List<PropertyInfo> ();
			var miscprops = new List<PropertyInfo> ();
			foreach (var p in type.GetProperties (BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)) {
				if (p.PropertyType.Namespace == "System.CodeDom" && !p.PropertyType.IsEnum)
					domprops.Add (p);
				else
					miscprops.Add (p);
			}

			string templateCtor = @"
		public {0} ({1})
		{{
			old = new Old{0} ({2});
			Initialize ();
		}}";

			foreach (var ctor in type.GetConstructors ()) {
				var c = new CodeConstructor () { Attributes = MemberAttributes.Public };
				foreach (var p in ctor.GetParameters ())
				
				// ZAPZAPZAP.

				string parDefs = String.Join (", ", (from p in ctor.GetParameters () select Format (p)).ToArray ());
				string pars = String.Join (", ", (from p in ctor.GetParameters () select p.ParameterType.Namespace == "System.CodeDom" && !p.ParameterType.IsEnum ? "(Old" + p.ParameterType.Name + ") " + p.Name : p.Name).ToArray ());
				csw.WriteLine (templateCtor, type.Name, parDefs, pars);
			}


			output.WriteLine ("// generic ordinal type for " + type);
			string template = @"
		// constructors, copied
{2}

		// old-to-new constructor
		internal {0} (Old{0} old)
		{{
			this.old = old;
			Initialize ();
		}}

		// initializer
		void Initialize ()
		{{
			// repeat for all auto (new-CodeDom-type) properties
			{3}
		}}

		// explicit conversion operator
		public static explicit operator Old{0} ({0} source)
		{{
			return source.old;
		}}

		// For a property whose type is new CodeDom type, just make it auto property (use private set for get-only ones)
		{4}

		// Non-CodeDom properties follow.
		{5}
	}}
";

			string templateInit = @"
			if (old.{0} != null)
				{0} = new {1}  (old.{0});";
			var isw = new StringWriter ();
			foreach (var p in domprops)
				isw.WriteLine (templateInit, p.Name, p.PropertyType.Name);

			string templateDomProp = @"
		public {3}{0} {1} {{ get; {2}set; }}";
			var dpsw = new StringWriter ();
			foreach (var p in domprops)
				dpsw.WriteLine (templateDomProp, p.PropertyType.Name, p.Name, p.IsSetterPublic () ? null : "private ", GetModifier (p));

			string templateOrdProp = @"
		public {3}{0} {1} {{
			get {{ return old.{1}; }}
			{2}
		}}";
			var nsw = new StringWriter ();
			foreach (var p in miscprops) {
				var setter = String.Format ("set {{ old.{0} = value; }}", p.Name);
				nsw.WriteLine (templateOrdProp, p.PropertyType.Name, p.Name, p.IsSetterPublic () ? setter : null, GetModifier (p));
			}

			// FIXME: write custom attributes
			output.WriteLine (template, type.Name, type.BaseType.Name, csw, isw, dpsw, nsw);
		}
*/

		string GetModifier (PropertyInfo p)
		{
			var m = p.GetGetMethod ();
			if (m.GetBaseDefinition () != m)
				return "override ";
			if (m.IsVirtual)
				return "virtual ";
			return null;
		}

		string Format (ParameterInfo p)
		{
			return String.Format ("{0}{1} {2}", p.GetCustomAttribute<ParamArrayAttribute> () != null ? "params " : null, p.ParameterType, p.Name);
		}
	}

	static class Extensions
	{
		public static T GetCustomAttribute<T> (this ParameterInfo p)
		{
			foreach (var a in p.GetCustomAttributes (true))
				if (a is T)
					return (T) a;
			return default (T);
		}

		public static bool IsSetterPublic (this PropertyInfo p)
		{
			var mi = p.GetSetMethod ();
			return mi != null && mi.IsPublic;
		}
	}
}
